name: Post to OpenAI Thread

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Don't call the API, just print the payload"
        required: false
        default: "false"
  schedule:
    - cron: "0 * * * *"  # hourly

permissions:
  contents: read

jobs:
  post:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_THREAD_ID: ${{ secrets.OPENAI_THREAD_ID }}
      OPENAI_ASSISTANT_ID: ${{ secrets.OPENAI_ASSISTANT_ID }}
      # SBX live endpoint (Bruce Lee Trading link)
      SBX_FEED_URL: "https://script.google.com/macros/s/AKfycbyQcze3w-ZU3jgI354M78Vz9gspByfSdU9fO7N7XIwA2kJlPCH-oaJtj1lSwpJ3sJET/exec"

    steps:
      - name: Sanity checks
        run: |
          test -n "$OPENAI_API_KEY" || { echo "âŒ Missing OPENAI_API_KEY"; exit 1; }
          test -n "$OPENAI_THREAD_ID" || { echo "âŒ Missing OPENAI_THREAD_ID"; exit 1; }
          test -n "$OPENAI_ASSISTANT_ID" || { echo "âŒ Missing OPENAI_ASSISTANT_ID"; exit 1; }
          echo "âœ… Secrets present."

      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set Git author
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name  "github-actions[bot]"

      - name: Compose message from handover + status files
        id: compose
        shell: bash
        run: |
          set -euo pipefail
          
          TS="$(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          LAST="$(tail -n 1 handover/SBX_HandoVER.md 2>/dev/null || true)"
          [ -z "$LAST" ] && LAST="(no last line found in handover/SBX_HandoVER.md)"

          EXTRA=""
          if [ -f status.json ]; then
            RUN_URL=$(jq -r '.workflow_url // empty' status.json || true)
            HOST=$(jq -r '.runner_hostname // empty' status.json || true)
            [ -n "$RUN_URL" ] && EXTRA="${EXTRA}\nrun: ${RUN_URL}"
            [ -n "$HOST" ] && EXTRA="${EXTRA}\nhost: ${HOST}"
          fi

          HANDOVER_SUMMARY=""
          if [ -f handover/status.json ]; then
            HANDOVER_SUMMARY=$(jq -r '.summary // empty' handover/status.json || true)
          fi

          TEXT="SBX handover sync â€” ${TS}\n${LAST}"
          [ -n "$HANDOVER_SUMMARY" ] && TEXT="${TEXT}\nsummary: ${HANDOVER_SUMMARY}"
          [ -n "$EXTRA" ] && TEXT="${TEXT}\n${EXTRA}"

          printf '%s' "$TEXT" > /tmp/body.txt

      - name: Fetch SBX live feed and append Top-5 summary
        shell: bash
        run: |
          set -euo pipefail
          echo "ðŸ”Ž Fetching SBX feed: $SBX_FEED_URL"
          curl -sS -L "$SBX_FEED_URL" -o /tmp/sbx_feed.raw || true

          # Default banner (kept tiny)
          echo -e "\n---\nSBX feed (auto-summary):" >> /tmp/body.txt

          # Try JSON first
          if jq -e . /tmp/sbx_feed.raw > /dev/null 2>&1; then
            # If the JSON wraps insights, try common keys; else assume it's an array of rows
            if jq -e '.SBX_Insights' /tmp/sbx_feed.raw > /dev/null 2>&1; then
              SRC='.SBX_Insights'
            elif jq -e '.insights' /tmp/sbx_feed.raw > /dev/null 2>&1; then
              SRC='.insights'
            else
              SRC='.'
            fi

            # Build a compact Top-5 line list; tolerate missing fields
            jq -r "$SRC
              | (if type==\"array\" then . else [] end)
              | .[0:50]
              | map({
                  sym:    (.symbol // .ticker // .pair // .Symbol // .Ticker // .Pair // \"?\"),
                  grade:  (.grade  // .Grade  // .rank  // .Rank  // empty),
                  score:  (.score  // .Score  // .RPI   // .eta   // empty),
                  bias:   (.bias   // .Bias   // .direction // .Direction // empty)
                })
              | .[0:5]
              | to_entries[]
              | \"â€¢ \(.value.sym)  grade=\(.value.grade // \"-\")  score=\(.value.score // \"-\")  bias=\(.value.bias // \"-\")\"
            " /tmp/sbx_feed.raw >> /tmp/body.txt || echo "â€¢ (unable to parse insights JSON)" >> /tmp/body.txt

          else
            # Not JSON â€“ treat as CSV/text; show first 5 non-header lines
            echo "(non-JSON feed; showing first lines)" >> /tmp/body.txt
            head -n 6 /tmp/sbx_feed.raw | sed '1,1d' | sed 's/^/â€¢ /' >> /tmp/body.txt || echo "â€¢ (no preview)" >> /tmp/body.txt
          fi

      - name: Preview composed body
        run: |
          echo "Preview to send:"
          sed -n '1,120p' /tmp/body.txt

      - name: Verify thread exists
        run: |
          set -euo pipefail
          curl -sS -w '\nHTTP:%{http_code}\n' \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "OpenAI-Beta: assistants=v2" \
            "https://api.openai.com/v1/threads/${OPENAI_THREAD_ID}" \
            | tee /tmp/thread_check.txt
          grep -q 'HTTP:200' /tmp/thread_check.txt || { echo "âŒ Thread not found"; exit 1; }

      - name: Dry run check
        if: ${{ github.event.inputs.dry_run == 'true' }}
        run: |
          echo "Dry run enabled. Would post this payload:"
          jq -nc --rawfile t /tmp/body.txt '{role:"user", content:[{type:"text", text:$t}]}'
          exit 0

      - name: Post message to OpenAI
        id: post
        shell: bash
        run: |
          set -euo pipefail
          jq -nc --rawfile t /tmp/body.txt '{role:"user", content:[{type:"text", text:$t}]}' > /tmp/payload.json
          curl -sS -o /tmp/resp.json -w '%{http_code}' \
            "https://api.openai.com/v1/threads/$OPENAI_THREAD_ID/messages" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "OpenAI-Beta: assistants=v2" \
            --data @/tmp/payload.json > /tmp/http.txt || true
          HTTP_CODE="$(cat /tmp/http.txt)"
          echo "HTTP: $HTTP_CODE"
          cat /tmp/resp.json || true
          [ "$HTTP_CODE" = "200" ] || { echo "âŒ Failed to post message"; exit 1; }
          MSG_ID=$(jq -r '.id // empty' /tmp/resp.json || true)
          [ -n "$MSG_ID" ] && echo "MSG_ID=$MSG_ID" >> "$GITHUB_OUTPUT"

      - name: Create run
        id: run
        shell: bash
        run: |
          set -euo pipefail
          curl -sS -o /tmp/run.json -w '%{http_code}' \
            "https://api.openai.com/v1/threads/$OPENAI_THREAD_ID/runs" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "OpenAI-Beta: assistants=v2" \
            -d "{\"assistant_id\":\"$OPENAI_ASSISTANT_ID\"}" > /tmp/http.txt
          HTTP_CODE="$(cat /tmp/http.txt)"
          echo "HTTP: $HTTP_CODE"
          cat /tmp/run.json || true
          [ "$HTTP_CODE" = "200" ] || { echo "âŒ Failed to create run"; exit 1; }
          RUN_ID=$(jq -r '.id // empty' /tmp/run.json)
          [ -n "$RUN_ID" ] || { echo "âŒ No run ID"; exit 1; }
          echo "RUN_ID=$RUN_ID" >> "$GITHUB_OUTPUT"

      - name: Wait for completion
        shell: bash
        run: |
          set -euo pipefail
          RUN_ID="${{ steps.run.outputs.RUN_ID }}"
          MAX_WAIT=300
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            curl -sS \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "OpenAI-Beta: assistants=v2" \
              "https://api.openai.com/v1/threads/$OPENAI_THREAD_ID/runs/$RUN_ID" > /tmp/run_status.json
            STATUS=$(jq -r '.status // empty' /tmp/run_status.json)
            echo "status: $STATUS"
            case "$STATUS" in
              completed) break ;;
              failed|cancelled|expired) cat /tmp/run_status.json; exit 1 ;;
            esac
            sleep 3; ELAPSED=$((ELAPSED+3))
          done
          [ $ELAPSED -lt $MAX_WAIT ] || { echo "âŒ Timeout"; exit 1; }

      - name: Get assistant response
        id: response
        shell: bash
        run: |
          set -euo pipefail
          curl -sS \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "OpenAI-Beta: assistants=v2" \
            "https://api.openai.com/v1/threads/$OPENAI_THREAD_ID/messages?order=desc&limit=10" > /tmp/messages.json
          echo "Messages snapshot:"
          jq '.' /tmp/messages.json | sed -n '1,120p'
          REPLY=$(jq -r '.data[] | select(.role=="assistant") | .content[0].text.value // empty' /tmp/messages.json | head -n 1)
          [ -n "$REPLY" ] || REPLY="(no response)"
          {
            echo "RESPONSE<<EOF"
            echo "$REPLY"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Summary
        run: |
          echo "âœ… Complete"
          echo "Message ID: ${{ steps.post.outputs.MSG_ID }}"
          echo "Run ID: ${{ steps.run.outputs.RUN_ID }}"
          echo ""
          echo "Response:"
          echo "${{ steps.response.outputs.RESPONSE }}"
